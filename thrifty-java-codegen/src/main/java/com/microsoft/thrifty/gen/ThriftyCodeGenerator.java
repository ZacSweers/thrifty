/*
 * Thrifty
 *
 * Copyright (c) Microsoft Corporation
 *
 * All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * THIS CODE IS PROVIDED ON AN  *AS IS* BASIS, WITHOUT WARRANTIES OR
 * CONDITIONS OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING
 * WITHOUT LIMITATION ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE,
 * FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABLITY OR NON-INFRINGEMENT.
 *
 * See the Apache Version 2.0 License for specific language governing permissions and limitations under the License.
 */
package com.microsoft.thrifty.gen;

import com.google.auto.value.AutoValue;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.HashMultimap;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Multimap;
import com.google.gson.Gson;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.SerializedName;
import com.microsoft.thrifty.compiler.spi.TypeProcessor;
import com.microsoft.thrifty.schema.Constant;
import com.microsoft.thrifty.schema.EnumType;
import com.microsoft.thrifty.schema.Field;
import com.microsoft.thrifty.schema.Location;
import com.microsoft.thrifty.schema.Named;
import com.microsoft.thrifty.schema.NamespaceScope;
import com.microsoft.thrifty.schema.Schema;
import com.microsoft.thrifty.schema.Service;
import com.microsoft.thrifty.schema.StructType;
import com.microsoft.thrifty.schema.ThriftType;
import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.FieldSpec;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.NameAllocator;
import com.squareup.javapoet.ParameterSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.moshi.Json;
import com.squareup.moshi.JsonAdapter;
import com.squareup.moshi.Moshi;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.ISODateTimeFormat;

import javax.annotation.Nullable;
import javax.lang.model.element.Modifier;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;

public final class ThriftyCodeGenerator {
    private static final String FILE_COMMENT =
            "Automatically generated by the Thrifty compiler; do not edit!\n"
                    + "Generated on: ";

    private static final ClassName SUPPORT_NONNULL = ClassName.get("android.support.annotation", "NonNull");
    private static final ClassName SUPPORT_NULLABLE = ClassName.get("android.support.annotation", "Nullable");
    private static final ClassName REDACTED = ClassName.get("com.ubercab.annotation", "Redacted");

    public static final String ADAPTER_FIELDNAME = "ADAPTER";

    private static final Pattern REDACTED_PATTERN = Pattern.compile(
            "@redacted", Pattern.CASE_INSENSITIVE);

    private static final DateTimeFormatter DATE_FORMATTER =
            ISODateTimeFormat.dateTime().withZoneUTC();

    private final TypeResolver typeResolver = new TypeResolver();
    private final Schema schema;
    private final ConstantBuilder constantBuilder;
    private final ServiceBuilder serviceBuilder;
    private TypeProcessor typeProcessor;
    private boolean emitAndroidAnnotations = true;
    private boolean emitParcelable = true;
    private boolean emitGson = true;
    private boolean emitMoshi = true;

    public ThriftyCodeGenerator(Schema schema) {
        this(
                schema,
                ClassName.get(ArrayList.class),
                ClassName.get(HashSet.class),
                ClassName.get(HashMap.class));
    }

    private ThriftyCodeGenerator(
            Schema schema,
            ClassName listClassName,
            ClassName setClassName,
            ClassName mapClassName) {

        Preconditions.checkNotNull(schema, "schema");
        Preconditions.checkNotNull(listClassName, "listClassName");
        Preconditions.checkNotNull(setClassName, "setClassName");
        Preconditions.checkNotNull(mapClassName, "mapClassName");

        this.schema = schema;
        typeResolver.setListClass(listClassName);
        typeResolver.setSetClass(setClassName);
        typeResolver.setMapClass(mapClassName);

        constantBuilder = new ConstantBuilder(typeResolver, schema);
        serviceBuilder = new ServiceBuilder(typeResolver, constantBuilder);
    }

    public ThriftyCodeGenerator withListType(String listClassName) {
        typeResolver.setListClass(ClassName.bestGuess(listClassName));
        return this;
    }

    public ThriftyCodeGenerator withSetType(String setClassName) {
        typeResolver.setSetClass(ClassName.bestGuess(setClassName));
        return this;
    }

    public ThriftyCodeGenerator withMapType(String mapClassName) {
        typeResolver.setMapClass(ClassName.bestGuess(mapClassName));
        return this;
    }

    public ThriftyCodeGenerator emitAndroidAnnotations(boolean shouldEmit) {
//        emitAndroidAnnotations = shouldEmit;
        return this;
    }

    public ThriftyCodeGenerator emitParcelable(boolean emitParcelable) {
//        this.emitParcelable = emitParcelable;
        return this;
    }

    public ThriftyCodeGenerator emitGson(boolean shouldEmit) {
        emitGson = shouldEmit;
        return this;
    }

    public ThriftyCodeGenerator emitMoshi(boolean shouldEmit) {
        this.emitMoshi = shouldEmit;
        return this;
    }

    public ThriftyCodeGenerator usingTypeProcessor(TypeProcessor typeProcessor) {
        this.typeProcessor = typeProcessor;
        return this;
    }

    public void generate(final File directory) throws IOException {
        generate(new FileWriter() {
            @Override
            public void write(JavaFile file) throws IOException {
                if (file != null) {
                    file.writeTo(directory);
                }
            }
        });
    }

    public void generate(final Appendable appendable) throws IOException {
        generate(new FileWriter() {
            @Override
            public void write(JavaFile file) throws IOException {
                if (file != null) {
                    file.writeTo(appendable);
                }
            }
        });
    }

    public ImmutableList<JavaFile> generateTypes() {
        ImmutableList.Builder<JavaFile> generatedTypes = ImmutableList.builder();

        for (EnumType type : schema.enums()) {
            TypeSpec spec = buildEnum(type);
            JavaFile file = assembleJavaFile(type, spec);
            if (file != null) {
                generatedTypes.add(file);
            }
        }

        for (StructType type : schema.structs()) {
            TypeSpec spec = buildStruct(type);
            JavaFile file = assembleJavaFile(type, spec);
            if (file != null) {
                generatedTypes.add(file);
            }
        }

        for (StructType type : schema.exceptions()) {
            TypeSpec spec = buildStruct(type);
            JavaFile file = assembleJavaFile(type, spec);
            if (file != null) {
                generatedTypes.add(file);
            }
        }

        for (StructType type : schema.unions()) {
            TypeSpec spec = buildStruct(type);
            JavaFile file = assembleJavaFile(type, spec);
            if (file != null) {
                generatedTypes.add(file);
            }
        }

        Multimap<String, Constant> constantsByPackage = HashMultimap.create();
        for (Constant constant : schema.constants()) {
            constantsByPackage.put(constant.getNamespaceFor(NamespaceScope.JAVA), constant);
        }

        for (Map.Entry<String, Collection<Constant>> entry : constantsByPackage.asMap().entrySet()) {
            String packageName = entry.getKey();
            Collection<Constant> values = entry.getValue();
            TypeSpec spec = buildConst(values);
            JavaFile file = assembleJavaFile(packageName, spec);
            if (file != null) {
                generatedTypes.add(file);
            }
        }

        for (Service type : schema.services()) {
            TypeSpec spec = serviceBuilder.buildServiceInterface(type);
            JavaFile file = assembleJavaFile(type, spec);
            if (file == null) {
                continue;
            }

            generatedTypes.add(file);

            spec = serviceBuilder.buildService(type, spec);
            file = assembleJavaFile(type, spec);
            if (file != null) {
                generatedTypes.add(file);
            }
        }

        return generatedTypes.build();
    }

    private interface FileWriter {
        void write(@Nullable JavaFile file) throws IOException;
    }

    private void generate(FileWriter writer) throws IOException {
        for (JavaFile file : generateTypes()) {
            writer.write(file);
        }
    }

    @Nullable
    private JavaFile assembleJavaFile(Named named, TypeSpec spec) {
        String packageName = named.getNamespaceFor(NamespaceScope.JAVA);
        if (Strings.isNullOrEmpty(packageName)) {
            throw new IllegalArgumentException("A Java package name must be given for java code generation");
        }

        return assembleJavaFile(packageName, spec, named.location());
    }

    @Nullable
    private JavaFile assembleJavaFile(String packageName, TypeSpec spec) {
        return assembleJavaFile(packageName, spec, null);
    }

    @Nullable
    private JavaFile assembleJavaFile(String packageName, TypeSpec spec, Location location) {
        if (typeProcessor != null) {
            spec = typeProcessor.process(spec);
            if (spec == null) {
                return null;
            }
        }

        JavaFile.Builder file = JavaFile.builder(packageName, spec)
                .skipJavaLangImports(true)
                .addFileComment(FILE_COMMENT + DATE_FORMATTER.print(System.currentTimeMillis()));

        if (location != null) {
            file.addFileComment("\nSource: $L", location);
        }

        return file.build();
    }

    TypeSpec buildStruct(StructType type) {
        String packageName = type.getNamespaceFor(NamespaceScope.JAVA);
        ClassName structTypeName = ClassName.get(packageName, type.name());
        ClassName builderTypeName = structTypeName.nestedClass("Builder");

        TypeSpec.Builder structBuilder = TypeSpec.classBuilder(type.name())
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                .addAnnotation(AutoValue.class);

        if (type.hasJavadoc()) {
            structBuilder.addJavadoc(type.documentation());
        }

        if (type.isException()) {
            structBuilder.superclass(Exception.class);
        }

        TypeSpec builderSpec = builderForAuto(type, structTypeName, builderTypeName);

        if (emitParcelable) {
            structBuilder.addSuperinterface(ClassName.get("android.os", "Parcelable"));
        }

        // TODO Make this only for debug/mock build types
        structBuilder.addType(builderSpec);

        // TODO This can be optional if we'd rather ref directly
        structBuilder.addMethod(MethodSpec.methodBuilder("builder")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(builderTypeName)
                .addCode(CodeBlock.builder()
                        .addStatement("return new AutoValue_$L.$T()", structTypeName.simpleName(), builderTypeName)
                        .build())
                .build());

        if (emitMoshi) {
            structBuilder.addMethod(MethodSpec.methodBuilder("jsonAdapter")
                    .addModifiers(Modifier.STATIC, Modifier.PUBLIC)
                    .returns(ParameterizedTypeName.get(ClassName.get(JsonAdapter.class), structTypeName))
                    .addParameter(ClassName.get(Moshi.class), "moshi")
                    .addCode(CodeBlock.builder()
                            .addStatement("return new AutoValue_$L.MoshiJsonAdapter(moshi)",
                                    structTypeName.simpleName())
                            .build())
                    .build());
        }

        if (emitGson) {
            structBuilder.addMethod(MethodSpec.methodBuilder("typeAdapter")
                    .addModifiers(Modifier.STATIC, Modifier.PUBLIC)
                    .returns(ParameterizedTypeName.get(ClassName.get(TypeAdapter.class), structTypeName))
                    .addParameter(ClassName.get(Gson.class), "gson")
                    .addCode(CodeBlock.builder()
                            .addStatement("return new AutoValue_$L.GsonTypeAdapter(gson)", structTypeName.simpleName())
                            .build())
                    .build());
        }

        for (Field field : type.fields()) {
            String name = field.name();
            ThriftType fieldType = field.type();
            ThriftType trueType = fieldType.getTrueType();
            TypeName fieldTypeName = typeResolver.getJavaClass(trueType);

            // Define field
            MethodSpec.Builder methodBuilder = MethodSpec.methodBuilder(name)
                    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                    .returns(fieldTypeName);

            if (emitAndroidAnnotations && !fieldTypeName.isPrimitive()) {
                if (field.required()) {
                    methodBuilder.addAnnotation(SUPPORT_NONNULL);
                } else {
                    methodBuilder.addAnnotation(SUPPORT_NULLABLE);
                }
            }

            boolean isRedacted =
                    field.annotations().containsKey("redacted")
                            || REDACTED_PATTERN.matcher(field.documentation()).find();
            if (isRedacted) {
                methodBuilder.addAnnotation(REDACTED);
            }

            if (!field.name().equals(field.thriftName())) {
                if (emitGson) {
                    methodBuilder.addAnnotation(AnnotationSpec.builder(SerializedName.class)
                            .addMember("value", "$S", field.thriftName())
                            .build());
                }

                if (emitMoshi) {
                    methodBuilder.addAnnotation(AnnotationSpec.builder(Json.class)
                            .addMember("name", "$S", field.thriftName())
                            .build());
                }
            }

            if (field.hasJavadoc()) {
                methodBuilder = methodBuilder.addJavadoc(field.documentation());
            }

            structBuilder.addMethod(methodBuilder.build());
        }

        return structBuilder.build();
    }

    private TypeSpec builderForAuto(
            StructType structType,
            ClassName structClassName,
            ClassName builderClassName) {
        TypeSpec.Builder builder = TypeSpec.classBuilder("Builder")
                .addAnnotation(AutoValue.Builder.class)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT, Modifier.STATIC);

        MethodSpec.Builder buildMethodBuilder = MethodSpec.methodBuilder("build")
                .returns(structClassName)
                .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT);

        // Add fields to the struct and set them in the ctor
        NameAllocator allocator = new NameAllocator();
        for (Field field : structType.fields()) {
            allocator.newName(field.name(), field.name());
        }

        for (Field field : structType.fields()) {
            ThriftType fieldType = field.type().getTrueType();
            TypeName javaTypeName = typeResolver.getJavaClass(fieldType);
            String fieldName = field.name();

            if (field.defaultValue() != null) {
                // TODO?
            }

            MethodSpec.Builder setterBuilder = MethodSpec.methodBuilder(fieldName)
                    .addModifiers(Modifier.PUBLIC, Modifier.ABSTRACT)
                    .returns(builderClassName);

            if (field.hasJavadoc()) {
                setterBuilder.addJavadoc(field.documentation());
            }

            ParameterSpec.Builder param = ParameterSpec.builder(javaTypeName, fieldName);

            if (emitAndroidAnnotations && !javaTypeName.isPrimitive()) {
                if (field.required()) {
                    param.addAnnotation(SUPPORT_NONNULL);
                } else {
                    param.addAnnotation(SUPPORT_NULLABLE);
                }
            } else {
                // TODO What do on prims?
            }
            setterBuilder.addParameter(param.build());
            builder.addMethod(setterBuilder.build());
        }

        builder.addMethod(buildMethodBuilder.build());
        return builder.build();
    }

    TypeSpec buildConst(Collection<Constant> constants) {
        TypeSpec.Builder builder = TypeSpec.classBuilder("Constants")
                .addModifiers(Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(MethodSpec.constructorBuilder()
                        .addModifiers(Modifier.PRIVATE)
                        .addCode("// no instances\n")
                        .build());

        final NameAllocator allocator = new NameAllocator();
        allocator.newName("Constants", "Constants");

        final AtomicInteger scope = new AtomicInteger(0); // used for temporaries in const collections
        final CodeBlock.Builder staticInit = CodeBlock.builder();
        final AtomicBoolean hasStaticInit = new AtomicBoolean(false);

        for (final Constant constant : constants) {
            final ThriftType type = constant.type().getTrueType();

            TypeName javaType = typeResolver.getJavaClass(type);
            if (type.isBuiltin() && type != ThriftType.STRING) {
                javaType = javaType.unbox();
            }
            final FieldSpec.Builder field = FieldSpec.builder(javaType, constant.name())
                    .addModifiers(Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);

            if (constant.hasJavadoc()) {
                field.addJavadoc(constant.documentation() + "\n\nGenerated from: " + constant.location());
            }

            type.accept(new SimpleVisitor<Void>() {
                @Override
                public Void visitBuiltin(ThriftType builtinType) {
                    field.initializer(constantBuilder.renderConstValue(null, allocator, scope, type, constant.value()));
                    return null;
                }

                @Override
                public Void visitEnum(ThriftType userType) {
                    field.initializer(constantBuilder.renderConstValue(null, allocator, scope, type, constant.value()));
                    return null;
                }

                @Override
                public Void visitList(ThriftType.ListType listType) {
                    if (constant.value().getAsList().isEmpty()) {
                        field.initializer("$T.emptyList()", TypeNames.COLLECTIONS);
                        return null;
                    }
                    initCollection("list", "unmodifiableList");
                    return null;
                }

                @Override
                public Void visitSet(ThriftType.SetType setType) {
                    if (constant.value().getAsList().isEmpty()) {
                        field.initializer("$T.emptySet()", TypeNames.COLLECTIONS);
                        return null;
                    }
                    initCollection("set", "unmodifiableSet");
                    return null;
                }

                @Override
                public Void visitMap(ThriftType.MapType mapType) {
                    if (constant.value().getAsMap().isEmpty()) {
                        field.initializer("$T.emptyMap()", TypeNames.COLLECTIONS);
                        return null;
                    }
                    initCollection("map", "unmodifiableMap");
                    return null;
                }

                private void initCollection(String tempName, String unmodifiableMethod) {
                    tempName += scope.incrementAndGet();
                    constantBuilder.generateFieldInitializer(
                            staticInit,
                            allocator,
                            scope,
                            tempName,
                            type,
                            constant.value(),
                            true);
                    staticInit.addStatement("$N = $T.$L($N)",
                            constant.name(),
                            TypeNames.COLLECTIONS,
                            unmodifiableMethod,
                            tempName);

                    hasStaticInit.set(true);
                }

                @Override
                public Void visitUserType(ThriftType userType) {
                    throw new UnsupportedOperationException("Struct-type constants are not supported");
                }

                @Override
                public Void visitTypedef(ThriftType.TypedefType typedefType) {
                    throw new AssertionError("Typedefs should have been resolved before now");
                }
            });

            builder.addField(field.build());
        }

        if (hasStaticInit.get()) {
            builder.addStaticBlock(staticInit.build());
        }

        return builder.build();
    }

    TypeSpec buildEnum(EnumType type) {
        ClassName enumClassName = ClassName.get(
                type.getNamespaceFor(NamespaceScope.JAVA),
                type.name());

        TypeSpec.Builder builder = TypeSpec.enumBuilder(type.name())
                .addModifiers(Modifier.PUBLIC)
                .addField(int.class, "value", Modifier.PUBLIC, Modifier.FINAL)
                .addMethod(MethodSpec.constructorBuilder()
                        .addParameter(int.class, "value")
                        .addStatement("this.$N = $N", "value", "value")
                        .build());

        if (type.hasJavadoc()) {
            builder.addJavadoc(type.documentation());
        }

        MethodSpec.Builder fromCodeMethod = MethodSpec.methodBuilder("findByValue")
                .addModifiers(Modifier.PUBLIC, Modifier.STATIC)
                .returns(enumClassName)
                .addParameter(int.class, "value")
                .beginControlFlow("switch (value)");

        for (EnumType.Member member : type.members()) {
            String name = member.name();

            int value = member.value();

            TypeSpec.Builder memberBuilder = TypeSpec.anonymousClassBuilder("$L", value);
            if (member.hasJavadoc()) {
                memberBuilder.addJavadoc(member.documentation());
            }

            builder.addEnumConstant(name, memberBuilder.build());

            fromCodeMethod.addStatement("case $L: return $N", value, name);
        }

        fromCodeMethod
                .addStatement("default: return null")
                .endControlFlow();

        builder.addMethod(fromCodeMethod.build());

        return builder.build();
    }
}
